import { Type, Event } from 'main.core';

import { mapGetters } from 'ui.vue3.vuex';
import { TextEditor } from 'ui.text-editor';
import { Button as UiButton, ButtonColor, ButtonSize } from 'ui.vue3.components.button';
import { BIcon, Outline } from 'ui.icon-set.api.vue';
import 'ui.icon-set.outline';

import { Core } from 'tasks.v2.core';
import { Model, EventName, ResultStatus, Analytics } from 'tasks.v2.const';
import { analytics } from 'tasks.v2.lib.analytics';
import { calendar } from 'tasks.v2.lib.calendar';
import { resultService } from 'tasks.v2.provider.service.result-service';
import { fileService, EntityTypes, type FileService } from 'tasks.v2.provider.service.file-service';
import {
	EntityTextArea,
	EntityTextTypes,
	entityTextEditor,
	CopilotButton,
	AttachButton,
	MentionButton,
	MoreButton,
	NumberListButton,
	BulletListButton,
	type EntityTextEditor,
} from 'tasks.v2.component.entity-text';
import type { TaskModel } from 'tasks.v2.model.tasks';
import type { ResultModel } from 'tasks.v2.model.results';
import type { UserModel } from 'tasks.v2.model.users';

import { resultsMeta } from '../../results-meta';

import './result-editor-sheet.css';

// @vue/component
export const ResultEditor = {
	name: 'TaskResultEditor',
	components: {
		BIcon,
		UiButton,
		EntityTextArea,
		CopilotButton,
		AttachButton,
		MentionButton,
		MoreButton,
		NumberListButton,
		BulletListButton,
	},
	inject: {
		taskId: {},
		task: {},
		analytics: {},
		cardType: {},
	},
	provide(): { fileService: FileService, entityTextEditor: EntityTextEditor }
	{
		return {
			editor: () => this.editor,
			fileService: () => this.fileService,
		};
	},
	props: {
		resultId: {
			type: [Number, String],
			required: true,
		},
		content: {
			type: String,
			default: '',
		},
		isResized: {
			type: Boolean,
			default: false,
		},
		showResize: {
			type: Boolean,
			default: true,
		},
	},
	emits: ['close', 'resize'],
	setup(props): { task: TaskModel, fileService: FileService, entityTextEditor: EntityTextEditor }
	{
		return {
			ButtonSize,
			ButtonColor,
			Outline,
			EntityTypes,
			EntityTextTypes,
			fileService: fileService.get(props.resultId, EntityTypes.Result),
			entityTextEditor: entityTextEditor.get(
				props.resultId,
				EntityTextTypes.Result,
				{
					content: props.content,
					blockSpaceInline: 'var(--ui-space-stack-xl)',
				},
			),
		};
	},
	data(): Object
	{
		return {
			isSaving: false,
			hasChanges: false,
			hasFilesChanges: false,
			buttonDisabled: !Type.isStringFilled(this.content),
		};
	},
	computed: {
		...mapGetters({
			currentUserId: `${Model.Interface}/currentUserId`,
		}),
		result(): ResultModel | null
		{
			return this.$store.getters[`${Model.Results}/getById`](this.resultId);
		},
		currentUser(): UserModel
		{
			return this.$store.getters[`${Model.Users}/getById`](this.currentUserId);
		},
		isEdit(): boolean
		{
			return Type.isNumber(this.resultId) && this.resultId > 0;
		},
		resultDate(): string
		{
			if (!this.result.createdAtTs)
			{
				return '';
			}

			return calendar.formatDateTime(this.result.createdAtTs);
		},
		title(): string
		{
			if (this.isEdit)
			{
				return this.loc('TASKS_V2_RESULT_TITLE_WITH_DATE', {
					'#DATE#': this.resultDate,
				});
			}

			return this.loc('TASKS_V2_RESULT_ADD');
		},
		buttonTitle(): string
		{
			return this.isEdit
				? this.loc('TASKS_V2_RESULT_BUTTON_SAVE')
				: this.loc('TASKS_V2_RESULT_BUTTON_SEND')
			;
		},
		readonly(): boolean
		{
			if (!this.result)
			{
				return !this.task?.rights?.read;
			}

			return !this.result?.rights?.edit;
		},
		editor(): TextEditor
		{
			return this.entityTextEditor.getEditor();
		},
		hasEditorChanges(): boolean
		{
			return this.hasChanges || this.hasFilesChanges;
		},
		resizeIcon(): string
		{
			return this.isResized ? Outline.COLLAPSE_L : Outline.EXPAND_L;
		},
		isDiskModuleInstalled(): boolean
		{
			return Core.getParams().features.disk;
		},
		isCopilotEnabled(): boolean
		{
			return Core.getParams().features.isCopilotEnabled;
		},
	},
	mounted(): void
	{
		if (!this.task.filledFields[resultsMeta.id])
		{
			void this.$store.dispatch(`${Model.Tasks}/setFieldFilled`, {
				id: this.taskId,
				fieldName: resultsMeta.id,
			});
		}

		if (!Type.isStringFilled(this.content) || this.resultId === 0)
		{
			setTimeout(this.focusToEnd, 400);
		}
	},
	unmounted(): void
	{
		if (!this.isEdit && !this.isSaving)
		{
			void this.$store.dispatch(`${Model.Results}/delete`, this.resultId);

			fileService.delete(this.resultId, EntityTypes.Result);
			entityTextEditor.delete(this.resultId, EntityTextTypes.Result);
		}
	},
	methods: {
		handleEditButtonClick(): void
		{
			if (this.isEdit)
			{
				this.handleClose();
			}
			else
			{
				this.handleAddResult();
			}
		},
		handleAddResult(): void
		{
			this.isSaving = true;

			const result = {
				...this.result,
				text: this.editor.getText(),
				author: this.currentUser,
				status: ResultStatus.Open,
				createdAtTs: Date.now(),
				updatedAtTs: Date.now(),
			};

			void this.addResult(result);

			this.handleClose();

			Event.EventEmitter.emit(EventName.ResultAdded, { taskId: this.taskId });
		},
		async addResult(result): void
		{
			const isSuccess = await resultService.add(this.taskId, result);

			this.sendAnalyticsResultAdd(isSuccess);
		},
		sendAnalyticsResultAdd(isSuccess: boolean): void
		{
			analytics.sendStatusSummaryAdd(this.analytics, {
				isSuccess,
				cardType: this.cardType,
				taskId: Type.isNumber(this.taskId) ? this.taskId : 0,
				element: Analytics.Element.AddResult,
				subSection: Analytics.SubSection.TaskCard,
			});
		},
		handleUpdateResult(): void
		{
			if (!this.hasEditorChanges)
			{
				return;
			}

			const fields = {
				text: this.editor.getText(),
				updatedAtTs: Date.now() / 1000,
				status: ResultStatus.Open,
			};

			void resultService.update(this.resultId, fields);

			this.hasChanges = false;
			this.hasFilesChanges = false;

			Event.EventEmitter.emit(EventName.ResultUpdated, { taskId: this.taskId, resultId: this.resultId });
		},
		handleEditorChange(): void
		{
			const preparedOldText = this.getPreparedText(this.content);
			const preparedNewText = this.getPreparedText(this.editor?.getText());

			this.hasChanges = preparedOldText !== preparedNewText;
			this.buttonDisabled = !Type.isStringFilled(preparedNewText);
		},
		getPreparedText(text): string | null
		{
			return text
				.replaceAll(/\[p]\n|\[p]\[\/p]|\[\/p]/gi, '')
				.trim()
			;
		},
		focusToEnd(): void
		{
			this.editor?.focus(null, { defaultSelection: 'rootEnd' });
		},
		handleClose(): void
		{
			if (this.isEdit)
			{
				this.handleUpdateResult();
			}

			this.$emit('close');
		},
	},
	template: `
		<div class="tasks-result-editor-wrapper" ref="wrapper">
			<div class="tasks-result-editor-header" ref="resultHeader">
				<div class="tasks-result-editor-title">{{ title }}</div>
				<div class="tasks-result-editor-field-actions">
					<BIcon
						v-if="showResize"
						class="tasks-result-editor-field-icon"
						:name="resizeIcon"
						hoverable
						@click="$emit('resize')"
					/>
					<BIcon
						:name="Outline.CROSS_L"
						hoverable
						class="tasks-result-editor-field-icon"
						@click="handleClose"
					/>
				</div>
			</div>
			<div class="tasks-result-editor-container">
				<EntityTextArea
					:entityId="resultId"
					:entityType="EntityTextTypes.Result"
					:readonly
					:removeFromServer="!isEdit"
					ref="resultTextArea"
					@change="handleEditorChange"
					@filesChange="hasFilesChanges = true"
				/>
			</div>
			<div v-if="!readonly" class="tasks-result-editor-footer" ref="resultActions">
				<div class="tasks-result-editor-action-list">
					<AttachButton v-if="isDiskModuleInstalled" :fileService/>
					<MentionButton :editor/>
					<BulletListButton :editor/>
					<NumberListButton :editor/>
					<MoreButton :editor/>
					<CopilotButton v-if="isCopilotEnabled" :editor/>
				</div>
				<div class="tasks-result-editor-footer-buttons">
					<UiButton
						:text="buttonTitle"
						:size="ButtonSize.MEDIUM"
						:color="ButtonColor.PRIMARY"
						:disabled="buttonDisabled || isSaving"
						@click="handleEditButtonClick"
					/>
				</div>
			</div>
		</div>
	`,
};
