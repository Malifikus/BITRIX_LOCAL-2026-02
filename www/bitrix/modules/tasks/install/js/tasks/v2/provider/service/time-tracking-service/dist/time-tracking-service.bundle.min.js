this.BX=this.BX||{};this.BX.Tasks=this.BX.Tasks||{};this.BX.Tasks.V2=this.BX.Tasks.V2||{};this.BX.Tasks.V2.Provider=this.BX.Tasks.V2.Provider||{};(function(e,s,t,i,a,r){"use strict";function o(e){return{id:e.id,taskId:e.taskId,userId:e.userId,seconds:e.seconds,source:e.source,text:e.text,createdAtTs:e.createdAtTs,startTs:e.startTs,stopTs:e.stopTs,rights:e.rights}}function d(e){return{id:e.id,taskId:e.taskId,userId:e.userId,seconds:e.seconds,source:e.source,text:e.text,createdAtTs:e.createdAtTs,startTs:e.startTs,stopTs:e.stopTs,rights:e.rights}}var n=babelHelpers.classPrivateFieldLooseKey("state");class c{constructor(){Object.defineProperty(this,n,{writable:true,value:{}})}async list(e,t={}){if(!Number.isInteger(e)){return}const a=Number.isInteger(t.size)?Number(t.size):undefined;if(!babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]||t.reset){babelHelpers.classPrivateFieldLooseBase(this,n)[n][e]={page:0,size:a!=null?a:20,isLoading:false,hasMore:true}}const r=babelHelpers.classPrivateFieldLooseBase(this,n)[n][e];if(r.isLoading||!r.hasMore){return}const o=r.page+1;const c=a!=null?a:r.size;r.isLoading=true;try{const t=await i.apiClient.post(s.Endpoint.TaskTimeTrackingList,{taskId:e,navigation:{page:o,size:c}});await this.$store.dispatch(`${s.Model.ElapsedTimes}/upsertMany`,t.map((e=>d(e))));r.page=o;r.size=c;r.hasMore=Array.isArray(t)?t.length===c:false}catch(e){console.error("ElapsedTime.list",e)}finally{babelHelpers.classPrivateFieldLooseBase(this,n)[n][e].isLoading=false}}isLoading(e){const s=babelHelpers.classPrivateFieldLooseBase(this,n)[n][e];return s&&s.isLoading}async listParticipants(e){try{const t=await i.apiClient.post(s.Endpoint.TaskTimeTrackingListParticipants,{taskId:e});const a=t.users.map((e=>r.UserMappers.mapDtoToModel(e)));await this.$store.dispatch(`${s.Model.Users}/upsertMany`,a);return[a,t.contribution]}catch(e){console.error("ElapsedTime.listParticipants",e);return[]}}async add(e,t){try{const r=a.taskService.getStoreTask(e);void a.taskService.updateStoreTask(e,{numberOfElapsedTimes:r.numberOfElapsedTimes+1,timeSpent:r.timeSpent+t.seconds});void this.$store.dispatch(`${s.Model.ElapsedTimes}/insert`,t);const n=await i.apiClient.post(s.Endpoint.TaskTimeTrackingAdd,{task:{id:e,elapsedTime:o(t)}});void this.$store.dispatch(`${s.Model.ElapsedTimes}/update`,{id:t.id,fields:d(n)});return n.id}catch(e){console.error("ElapsedTime.add",e);return null}}async update(e,t){try{const r=this.$store.getters[`${s.Model.ElapsedTimes}/getById`](t.id);const d=t.seconds-r.seconds;const n=a.taskService.getStoreTask(e);void a.taskService.updateStoreTask(e,{timeSpent:n.timeSpent+d});void this.$store.dispatch(`${s.Model.ElapsedTimes}/update`,{id:t.id,fields:t});await i.apiClient.post(s.Endpoint.TaskTimeTrackingUpdate,{elapsedTime:o(t)})}catch(e){console.error("ElapsedTime.update",e)}}async delete(e,t){try{const r=a.taskService.getStoreTask(e);void a.taskService.updateStoreTask(e,{numberOfElapsedTimes:r.numberOfElapsedTimes-1,timeSpent:r.timeSpent-t.seconds});void this.$store.dispatch(`${s.Model.ElapsedTimes}/delete`,t.id);await i.apiClient.post(s.Endpoint.TaskTimeTrackingDelete,{elapsedTimeId:t.id})}catch(e){console.error("ElapsedTime.delete",e)}}get $store(){return t.Core.getStore()}}const l=new c;const p={mapModelToDto:o,mapDtoToModel:d};e.timeTrackingService=l;e.TimeTrackingMappers=p})(this.BX.Tasks.V2.Provider.Service=this.BX.Tasks.V2.Provider.Service||{},BX.Tasks.V2.Const,BX.Tasks.V2,BX.Tasks.V2.Lib,BX.Tasks.V2.Provider.Service,BX.Tasks.V2.Provider.Service);
//# sourceMappingURL=time-tracking-service.bundle.map.js