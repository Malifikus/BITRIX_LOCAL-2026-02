this.BX=this.BX||{};this.BX.Tasks=this.BX.Tasks||{};this.BX.Tasks.V2=this.BX.Tasks.V2||{};(function(t,e,s,a){"use strict";var r;const n=e.Extension.getSettings("tasks.v2.lib.calendar").calendarSettings;const o=new Set(n.HOLIDAYS.map((({M:t,D:e})=>`${t}.${e}`)));const i=new Set(n.WEEKEND.map((t=>({SU:0,MO:1,TU:2,WE:3,TH:4,FR:5,SA:6}[t]))));const{H:u,M:c}=n.HOURS.START;const{H:l,M:T}=n.HOURS.END;const D=s.DurationFormat.getUnitDurations();const h=(l*60+T-(u*60+c))*6e4;const g=h*(7-i.size);const m=new(r=babelHelpers.classPrivateFieldLooseKey("calculateRangeTs"),class{constructor(){Object.defineProperty(this,r,{value:H})}get weekStart(){return n.WEEK_START}get workdayDuration(){return h}get workdayStart(){return n.HOURS.START}get dayStartTime(){return`${String(u).padStart(2,"0")}:${String(c).padStart(2,"0")}`}get dayEndTime(){return`${String(l).padStart(2,"0")}:${String(T).padStart(2,"0")}`}formatDateTime(t,{forceYear:r,removeOffset:n}={}){if(!t){return""}const o=r||new Date(t).getFullYear()!==(new Date).getFullYear();const i=e.Loc.getMessage("TASKS_V2_DATE_TIME_FORMAT",{"#DATE#":s.DateTimeFormat.getFormat(o?"LONG_DATE_FORMAT":"DAY_MONTH_FORMAT"),"#TIME#":s.DateTimeFormat.getFormat("SHORT_TIME_FORMAT")});const u=n?0:a.timezone.getOffset(t);return s.DateTimeFormat.format(i,(t+u)/1e3)}formatDate(t,{forceYear:e}={}){if(!t){return""}const r=e||new Date(t).getFullYear()!==(new Date).getFullYear();const n=s.DateTimeFormat.getFormat(r?"LONG_DATE_FORMAT":"DAY_MONTH_FORMAT");const o=a.timezone.getOffset(t);return s.DateTimeFormat.format(n,(t+o)/1e3)}formatDuration(t,e){const a=e?this.workdayDuration:D.d;const r=t/D.i;const n=t/D.H;const o=t/a;const[i,u]={[true]:[Math.floor(r)*D.i,"i"],[Number.isInteger(n)]:[n*D.H,"H"],[Number.isInteger(o)]:[o*D.d,"d"]}.true;return new s.DurationFormat(i).format({format:u})}calculateDuration(t,e){const s=this.setHours(t,l,T);if(e<s){return e-t}let a=this.setHours(t+D.d,u,c);let r=s-t;while(a<e){if(this.isWorkDay(a)){r+=Math.min(a+h,e)-a}a+=D.d}return r}calculateStartTs(t,e,s){return t!=null?t:babelHelpers.classPrivateFieldLooseBase(this,r)[r](e,s,true)}calculateEndTs(t,e,s){if(!t){return e}let o=s;let l=t;const T=(1+7-new Date(l-a.timezone.getOffset(l)).getDay())%7;const m=this.setHours(l+D.d*T,u,c);const H=this.calculateDuration(l,m);if(o<=H){return babelHelpers.classPrivateFieldLooseBase(this,r)[r](l,o)}o-=H;l=m;const f=new Date(l).setHours(0,0,0);const S=Math.max(Math.floor(o/g)-1,0);o-=g*S;l=this.setHours(l+D.d*S*7,u,c);const M=new Date(l).setHours(0,0,0)-D.d;const d=new Date(f).getFullYear();const F=new Date(M).getFullYear();const O=Array.from({length:F-d+1},((t,e)=>e+d)).flatMap((t=>n.HOLIDAYS.map((({M:e,D:s})=>new Date(t,e-1,s).getTime())))).filter((t=>f<=t&&t<=M&&!i.has(new Date(t).getDay())));if(O.length>0){return this.calculateEndTs(l,e,o+h*O.length)}return babelHelpers.classPrivateFieldLooseBase(this,r)[r](l,o)}clampWorkDateTime(t){if(!t){return null}let e=t;while(!this.isWorkDay(e)){e=this.setHours(e+D.d,u,c)}const s=this.setHours(e,u,c);const a=this.setHours(e,l,T);return Math.min(Math.max(e,s),a)}isWorkDay(t){const e=new Date(t);return!i.has(e.getUTCDay())&&!o.has(`${e.getUTCMonth()+1}.${e.getUTCDate()}`)}setHours(t,e,s){return new Date(t).setHours(e,s,0,0)-a.timezone.getOffset(t)}createDateFromUtc(t){return new Date(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate(),t.getUTCHours(),t.getUTCMinutes())}});function H(t,e,s){const a=s?-1:1;const r=s?n.HOURS.END:n.HOURS.START;const o=s?n.HOURS.START:n.HOURS.END;let i=t;let u=e;while(u>0){if(this.isWorkDay(i)){const t=Math.abs(i-this.setHours(i,o.H,o.M));const e=i+Math.min(t,u,h)*a;u-=Math.abs(i-e);if(u===0){return e}}i=this.setHours(i+D.d*a,r.H,r.M)}return t}t.calendar=m})(this.BX.Tasks.V2.Lib=this.BX.Tasks.V2.Lib||{},BX,BX.Main,BX.Tasks.V2.Lib);
//# sourceMappingURL=calendar.bundle.map.js